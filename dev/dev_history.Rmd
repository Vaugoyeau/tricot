---
title: "dev_history.Rmd for working package"
author: "Sébastien Rochette"
date: "23/01/2021"
output: html_document
---

```{r development, include=FALSE}
library(testthat)
```

<!--
# Description of your package

This will fill the description of your package.
Add this chunk using `fusen::description_chunk()`
--> 

```{r description}
# Describe your package
fusen::fill_description(
  fields = list(
    Title = "Create a kniting image from an image",
    Description = "From any image, creation of an image to knit a rectangle representing the simplified image and a summary table of colors and number of stitches according to the chosen needles.",
    `Authors@R` = c(
      person("Marie", "Vaugoyeau", email = "marie.vaugoyeau@gmail.com", role = c("aut", "cre")),
      person(given = "MStats", role = "cph")
    )
  )
)
# Define License with use_*_license()
usethis::use_mit_license("Marie Vaugoyeau")
```
  
  
# Load image  

```{r function}

#' Load image
#'
#' @param path Path to load image
#' @inheritParams magick::image_read 
#' @inheritParams stringr::str_detect
#'
#' @return
#' Magick image in R
#' @export
#'
#' @examples
image_load <- function(path) {
  if (!file.exists(path)) {stop("path is incorrect")}
  
  if (sum(stringr::str_detect(path, c(".jpeg", ".jpg", ".png", ".tif"))) > 0) {magick::image_read(path)}
  else if (stringr::str_detect(path, ".pdf")) {magick::image_read_pdf(path, pages = 1)}
  else {stop("format is not supported")}
}

```
  
```{r examples}
image_load("img/PeintureLaetitia.jpg")
image_load("img/Montagne.pdf")
image_load("img/Pingouin.png")
image_load("img/Monstre.tif")
```

```{r tests}
test_that("load image and show error if needed", {
  expect_true(class(image_load("img/PeintureLaetitia.jpg")) == "magick-image")
  expect_error(image_load("text"))
})
```

# Calculate the size of square based on the information provided on the label   
  
Normally on the balls of wool there is the information to knit a square of 10 x 10 cm.
  
```{r function-1}

#' Square of size
#'
#' @param rg Row number to have 10 cm
#' @param m Stitch number to have 10 cm
#'
#' @return
#' Square size to do grid on image
#' @export
#'
#' @examples
square_size <- function(rg, m) {
  if (!is.numeric(rg)) {stop("rg should be numeric")}
  if (!is.numeric(m)) {stop("m should be numeric")}
  
  c(
    height = round(10/rg, 3),
    width = round(10/m, 3)
  )
}

```
  
```{r examples-1}
square_size(31,24)
square_size(35,26)
```

```{r tests-1}
test_that("calcule square size and show error if needed", {
  expect_true(sum(square_size(31,24) == c(height = 0.323, width = 0.417)) == 2)
  expect_error(square_size("text"))
})
```
  
  
# Calculate the size of pixel   
  
Calculation of the pixel size according to the size of the row and the previously given stitch and with the size of the knit you are looking for.  
  
```{r function-2}

#' Grid size
#'
#' @param h Expected height (cm) of knitting
#' @param w Expected width (cm) of knitting
#' @param ss Size square calculated from square_size()
#'
#' @return
#' Grid size to do grid on image
#' @export
#'
#' @examples
grid_size <- function(h, w, ss) {
  if (!is.numeric(h)) {stop("h should be numeric")}
  if (!is.numeric(w)) {stop("w should be numeric")}
  
  c(
    grid = ceiling(h/ss["height"]),
    grid = ceiling(w/ss["width"])
  )
}

```
  
```{r examples-2}
grid_size(20, 20, square_size(31,24)) 
grid_size(5, 5, square_size(35,26))
```

```{r tests-2}
test_that("calcule grid size and show error if needed", {
  expect_true(sum(grid_size(5, 5, square_size(35,26)) == c(grid.height = 18, grid.width = 13)) == 2)
  expect_error(square_size("text"))
})
```
  
  
# Calculate the square size in image     
  
```{r function-3}

#' Pixel size in image
#'
#' @param img Magick image
#' @param gs Grid size calculated from grid_size()
#' @inheritParams magick::image_info 
#'
#' @return
#' Pixel size of knitting image
#' @export
#'
#' @examples
pixel_size <- function(img, gs) {
  
  if(class(img) != "magick-image") {stop("img must be magick image")}
  if (!is.numeric(gs)) {stop("gs should be numeric")}
  if (length(gs) != 2) {stop("gs should have only two values")}

  c(
    pixel = floor(magick::image_info(img)$height/gs["grid.height"]),
    pixel = floor(magick::image_info(img)$width/gs["grid.width"])
  )
  
}

```
  
```{r examples-3}

pixel_size(img, gs) # Montagne

```

```{r tests-3}
test_that("calcule pixel size and show error if needed", {
  expect_true(sum(pixel_size(image_load("img/Pingouin.png"), c("grid.height" = 31, "grid.width" = 24)) == c(pixel.height = 38, pixel.width = 49)) == 2)
  expect_error(pixel_size("text"))
})
```
  
  
# Creation of new image  
  
```{r function-4}

#' Create image to knit
#'
#' @param img_raster Magick image raster
#' @param ps Pixel size calculated from pixel_size()
#'
#' @inheritParams magick::image_read 
#' @inheritParams stringr::str_detect
#'
#' @return
#' Knitting image
#' @export
#'
#' @examples
knitting_image <- function(img, ps) {
  
  if (class(img) != "magick-image") {stop("image should be magick image")}
  if (!is.numeric(ps)) {stop("ps should be numeric")}
  if (length(ps) != 2) {stop("ps should have two values")}
  
  
  img_raster <- magick::image_raster(img)
  
  if (max(img_raster$x)/ps[2] == ceiling(max(img_raster$x)/ps[2])) {
    image_x <- seq(from = 1, to = max(img_raster$x), by = ps[2])
  } else {
    image_x <- c(seq(from = 1, to = max(img_raster$x), by = ps[2]), max(img_raster$x))
  }
  
    if (max(img_raster$y)/ps[1] == ceiling(max(img_raster$y)/ps[1])) {
    image_y <- seq(from = 1, to = max(img_raster$y), by = ps[1])
  } else {
    image_y <- c(seq(from = 1, to = max(img_raster$y), by = ps[1]), max(img_raster$y))
  }
  
  tricot <- tibble::tibble('x' = as.numeric(), 'y' = as.numeric(), 'col' = as.character())
  
  for (w in c(1:(length(image_x)-1))){
    
    for (h in c(1:(length(image_y)-1))){
      
      tricot <- dplyr::bind_rows(
        tricot,
        tibble::tibble(
          x = w,
          y = h,
          col = as.character(
            dplyr::select(
              dplyr::slice(
                dplyr::count(
                  dplyr::filter(
                    img_raster,
                    dplyr::between(x, image_x[w], image_x[(w+1)]),
                    dplyr::between(y, image_y[h], image_y[(h+1)])
                  ),
                  col
                ),
                1),
              col
            )
          )
        )
      )
 
    }
    
  }
  
  return(tricot)
  
}

```
  
  
```{r test_mise_en_forme_image}

test <- knitting_image(img, ps)

test_bis <- tibble::tibble(x = rep(c(1:3), 2), y = rep(c(1:2),3), col = c("#000000ff", "#00642dff", "#0070c0ff", "#00b050ff", "#00b0f0ff", "#ffc000ff"))

test_bis <- tibble::tibble(x = rep(c(1:6), 4), y = rep(c(1:4), 6), col = c("#000000ff", "#00642dff", "#0070c0ff", "#00b050ff", "#00b0f0ff", "#ffc000ff", "#000000ff", "#00642dff", "#0070c0ff", "#00b050ff", "#00b0f0ff", "#ffc000ff", "#000000ff", "#00642dff", "#0070c0ff", "#00b050ff", "#00b0f0ff", "#ffc000ff", "#000000ff", "#00642dff", "#0070c0ff", "#00b050ff", "#00b0f0ff", "#ffc000ff"))

test <- magick::image_scale(img, "35x26")
test_raster <- magick::image_raster(test)


ggplot2::ggplot(test_raster) + 
  ggplot2::aes(x = -x, y = -y, fill = col) + 
  ggplot2::geom_raster() + 
  ggplot2::scale_fill_manual(values = as.character(test_raster$col)) + 
  ggplot2::theme(
    legend.position = "none", 
    panel.background = ggplot2::element_blank(),
    panel.grid.major = ggplot2::element_line(colour = "black"),
    panel.grid.minor = ggplot2::element_line(colour = "grey"))

```

  
STOP, je me suis arrêtée là !
  
  
# Application of grid on image     
  
Now we have grid size and image, we need to find color of each pixel of grid.  
  
```{r function-3}

#' Extract color from square
#'
#' @param image Magick image from image_load
#' @param w Expected width (cm) of knitting
#' @param ss Size square calculated from square_size()
#'
#' @return
#' Grid size to do grid on image
#' @export
#'
#' @examples
grid_size <- function(h, w, ss) {
  if (!is.numeric(h)) {stop("h should be numeric")}
  if (!is.numeric(w)) {stop("w should be numeric")}
  
  c(
    grid_height = ceiling(h/ss["height"]),
    grid_width = ceiling(w/ss["width"])
  )
}

```
  
```{r examples-2}
grid_size(5, 5, square_size(31,24)) 
grid_size(5, 5, square_size(35,26))
```

```{r tests-2}
test_that("calcule grid size and show error if needed", {
  expect_true(sum(grid_size(5, 5, square_size(35,26)) == c(grid_height = 18, grid_width = 13)) == 2)
  expect_error(square_size("text"))
})
```
  
  
  




# Calculate the median of a vector

```{r function}
#' My median
#'
#' @param x Vector of Numeric values
#' @inheritParams stats::median
#'
#' @return
#' Median of vector x
#' @export
#'
#' @examples
my_median <- function(x, na.rm = TRUE) {
  if (!is.numeric(x)) {stop("x should be numeric")}
  stats::median(x, na.rm = na.rm)
}
```

```{r examples}
my_median(1:12)
```

```{r tests}
test_that("my_median works properly and show error if needed", {
  expect_true(my_median(1:12) == 6.5)
  expect_error(my_median("text"))
})
```

# Calculate the mean of a vector
## Use sub-functions in the same chunk

```{r function-1}
#' My Other median
#'
#' @param x Vector of Numeric values
#' @inheritParams stats::median
#'
#' @return
#' Median of vector x
#' @export
#'
#' @examples
my_other_median <- function(x, na.rm = TRUE) {
  if (!is.numeric(x)) {stop("x should be numeric")}
  sub_median(x, na.rm =na.rm)
}

#' Core of the median not exported
#' @param x Vector of Numeric values
#' @inheritParams stats::median
sub_median <- function(x, na.rm = TRUE) {
  stats::median(x, na.rm)
}
```

```{r examples-1}
my_other_median(1:12)
```

```{r tests-1}
test_that("my_median works properly and show error if needed", {
  expect_true(my_other_median(1:12) == 6.5)
  expect_error(my_other_median("text"))
})
```

# There can be development actions

These will be included in the `dev_history.R` file of your package, but won't be direct part of it.

```{r development-1, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(rmd = "dev/dev_history.Rmd")
```


# Inflate your package

You're one inflate from paper to box.
Build your package from this very Rmarkdown using `fusen::inflate()`

- Verify your `"DESCRIPTION"` file has been updated
- Verify your function is in `"R/"` directory
- Verify your test is in `"tests/testthat/"` directory
- Verify this Rmd appears in `"vignettes/"` directory

